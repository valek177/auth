// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/valek177/auth/internal/repository.UserRedisRepository -o user_redis_repository_minimock.go -n UserRedisRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/valek177/auth/internal/model"
)

// UserRedisRepositoryMock implements mm_repository.UserRedisRepository
type UserRedisRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateUser          func(ctx context.Context, user *model.User) (err error)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(ctx context.Context, user *model.User)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mUserRedisRepositoryMockCreateUser

	funcDeleteUser          func(ctx context.Context, id int64) (err error)
	funcDeleteUserOrigin    string
	inspectFuncDeleteUser   func(ctx context.Context, id int64)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mUserRedisRepositoryMockDeleteUser

	funcGetUser          func(ctx context.Context, id int64) (up1 *model.User, err error)
	funcGetUserOrigin    string
	inspectFuncGetUser   func(ctx context.Context, id int64)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mUserRedisRepositoryMockGetUser

	funcSetExpireUser          func(ctx context.Context, id int64) (err error)
	funcSetExpireUserOrigin    string
	inspectFuncSetExpireUser   func(ctx context.Context, id int64)
	afterSetExpireUserCounter  uint64
	beforeSetExpireUserCounter uint64
	SetExpireUserMock          mUserRedisRepositoryMockSetExpireUser
}

// NewUserRedisRepositoryMock returns a mock for mm_repository.UserRedisRepository
func NewUserRedisRepositoryMock(t minimock.Tester) *UserRedisRepositoryMock {
	m := &UserRedisRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateUserMock = mUserRedisRepositoryMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*UserRedisRepositoryMockCreateUserParams{}

	m.DeleteUserMock = mUserRedisRepositoryMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*UserRedisRepositoryMockDeleteUserParams{}

	m.GetUserMock = mUserRedisRepositoryMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*UserRedisRepositoryMockGetUserParams{}

	m.SetExpireUserMock = mUserRedisRepositoryMockSetExpireUser{mock: m}
	m.SetExpireUserMock.callArgs = []*UserRedisRepositoryMockSetExpireUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserRedisRepositoryMockCreateUser struct {
	optional           bool
	mock               *UserRedisRepositoryMock
	defaultExpectation *UserRedisRepositoryMockCreateUserExpectation
	expectations       []*UserRedisRepositoryMockCreateUserExpectation

	callArgs []*UserRedisRepositoryMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRedisRepositoryMockCreateUserExpectation specifies expectation struct of the UserRedisRepository.CreateUser
type UserRedisRepositoryMockCreateUserExpectation struct {
	mock               *UserRedisRepositoryMock
	params             *UserRedisRepositoryMockCreateUserParams
	paramPtrs          *UserRedisRepositoryMockCreateUserParamPtrs
	expectationOrigins UserRedisRepositoryMockCreateUserExpectationOrigins
	results            *UserRedisRepositoryMockCreateUserResults
	returnOrigin       string
	Counter            uint64
}

// UserRedisRepositoryMockCreateUserParams contains parameters of the UserRedisRepository.CreateUser
type UserRedisRepositoryMockCreateUserParams struct {
	ctx  context.Context
	user *model.User
}

// UserRedisRepositoryMockCreateUserParamPtrs contains pointers to parameters of the UserRedisRepository.CreateUser
type UserRedisRepositoryMockCreateUserParamPtrs struct {
	ctx  *context.Context
	user **model.User
}

// UserRedisRepositoryMockCreateUserResults contains results of the UserRedisRepository.CreateUser
type UserRedisRepositoryMockCreateUserResults struct {
	err error
}

// UserRedisRepositoryMockCreateUserOrigins contains origins of expectations of the UserRedisRepository.CreateUser
type UserRedisRepositoryMockCreateUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mUserRedisRepositoryMockCreateUser) Optional() *mUserRedisRepositoryMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for UserRedisRepository.CreateUser
func (mmCreateUser *mUserRedisRepositoryMockCreateUser) Expect(ctx context.Context, user *model.User) *mUserRedisRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRedisRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRedisRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("UserRedisRepositoryMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &UserRedisRepositoryMockCreateUserParams{ctx, user}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for UserRedisRepository.CreateUser
func (mmCreateUser *mUserRedisRepositoryMockCreateUser) ExpectCtxParam1(ctx context.Context) *mUserRedisRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRedisRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRedisRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserRedisRepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserRedisRepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectUserParam2 sets up expected param user for UserRedisRepository.CreateUser
func (mmCreateUser *mUserRedisRepositoryMockCreateUser) ExpectUserParam2(user *model.User) *mUserRedisRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRedisRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRedisRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserRedisRepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserRedisRepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.user = &user
	mmCreateUser.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the UserRedisRepository.CreateUser
func (mmCreateUser *mUserRedisRepositoryMockCreateUser) Inspect(f func(ctx context.Context, user *model.User)) *mUserRedisRepositoryMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for UserRedisRepositoryMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by UserRedisRepository.CreateUser
func (mmCreateUser *mUserRedisRepositoryMockCreateUser) Return(err error) *UserRedisRepositoryMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRedisRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRedisRepositoryMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &UserRedisRepositoryMockCreateUserResults{err}
	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the UserRedisRepository.CreateUser method
func (mmCreateUser *mUserRedisRepositoryMockCreateUser) Set(f func(ctx context.Context, user *model.User) (err error)) *UserRedisRepositoryMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the UserRedisRepository.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the UserRedisRepository.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the UserRedisRepository.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mUserRedisRepositoryMockCreateUser) When(ctx context.Context, user *model.User) *UserRedisRepositoryMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRedisRepositoryMock.CreateUser mock is already set by Set")
	}

	expectation := &UserRedisRepositoryMockCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &UserRedisRepositoryMockCreateUserParams{ctx, user},
		expectationOrigins: UserRedisRepositoryMockCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up UserRedisRepository.CreateUser return parameters for the expectation previously defined by the When method
func (e *UserRedisRepositoryMockCreateUserExpectation) Then(err error) *UserRedisRepositoryMock {
	e.results = &UserRedisRepositoryMockCreateUserResults{err}
	return e.mock
}

// Times sets number of times UserRedisRepository.CreateUser should be invoked
func (mmCreateUser *mUserRedisRepositoryMockCreateUser) Times(n uint64) *mUserRedisRepositoryMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of UserRedisRepositoryMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mUserRedisRepositoryMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_repository.UserRedisRepository
func (mmCreateUser *UserRedisRepositoryMock) CreateUser(ctx context.Context, user *model.User) (err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, user)
	}

	mm_params := UserRedisRepositoryMockCreateUserParams{ctx, user}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := UserRedisRepositoryMockCreateUserParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("UserRedisRepositoryMock.CreateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmCreateUser.t.Errorf("UserRedisRepositoryMock.CreateUser got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("UserRedisRepositoryMock.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the UserRedisRepositoryMock.CreateUser")
		}
		return (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, user)
	}
	mmCreateUser.t.Fatalf("Unexpected call to UserRedisRepositoryMock.CreateUser. %v %v", ctx, user)
	return
}

// CreateUserAfterCounter returns a count of finished UserRedisRepositoryMock.CreateUser invocations
func (mmCreateUser *UserRedisRepositoryMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of UserRedisRepositoryMock.CreateUser invocations
func (mmCreateUser *UserRedisRepositoryMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to UserRedisRepositoryMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mUserRedisRepositoryMockCreateUser) Calls() []*UserRedisRepositoryMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*UserRedisRepositoryMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *UserRedisRepositoryMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *UserRedisRepositoryMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRedisRepositoryMock.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRedisRepositoryMock.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRedisRepositoryMock.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to UserRedisRepositoryMock.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRedisRepositoryMock.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mUserRedisRepositoryMockDeleteUser struct {
	optional           bool
	mock               *UserRedisRepositoryMock
	defaultExpectation *UserRedisRepositoryMockDeleteUserExpectation
	expectations       []*UserRedisRepositoryMockDeleteUserExpectation

	callArgs []*UserRedisRepositoryMockDeleteUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRedisRepositoryMockDeleteUserExpectation specifies expectation struct of the UserRedisRepository.DeleteUser
type UserRedisRepositoryMockDeleteUserExpectation struct {
	mock               *UserRedisRepositoryMock
	params             *UserRedisRepositoryMockDeleteUserParams
	paramPtrs          *UserRedisRepositoryMockDeleteUserParamPtrs
	expectationOrigins UserRedisRepositoryMockDeleteUserExpectationOrigins
	results            *UserRedisRepositoryMockDeleteUserResults
	returnOrigin       string
	Counter            uint64
}

// UserRedisRepositoryMockDeleteUserParams contains parameters of the UserRedisRepository.DeleteUser
type UserRedisRepositoryMockDeleteUserParams struct {
	ctx context.Context
	id  int64
}

// UserRedisRepositoryMockDeleteUserParamPtrs contains pointers to parameters of the UserRedisRepository.DeleteUser
type UserRedisRepositoryMockDeleteUserParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserRedisRepositoryMockDeleteUserResults contains results of the UserRedisRepository.DeleteUser
type UserRedisRepositoryMockDeleteUserResults struct {
	err error
}

// UserRedisRepositoryMockDeleteUserOrigins contains origins of expectations of the UserRedisRepository.DeleteUser
type UserRedisRepositoryMockDeleteUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mUserRedisRepositoryMockDeleteUser) Optional() *mUserRedisRepositoryMockDeleteUser {
	mmDeleteUser.optional = true
	return mmDeleteUser
}

// Expect sets up expected params for UserRedisRepository.DeleteUser
func (mmDeleteUser *mUserRedisRepositoryMockDeleteUser) Expect(ctx context.Context, id int64) *mUserRedisRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserRedisRepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserRedisRepositoryMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.paramPtrs != nil {
		mmDeleteUser.mock.t.Fatalf("UserRedisRepositoryMock.DeleteUser mock is already set by ExpectParams functions")
	}

	mmDeleteUser.defaultExpectation.params = &UserRedisRepositoryMockDeleteUserParams{ctx, id}
	mmDeleteUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// ExpectCtxParam1 sets up expected param ctx for UserRedisRepository.DeleteUser
func (mmDeleteUser *mUserRedisRepositoryMockDeleteUser) ExpectCtxParam1(ctx context.Context) *mUserRedisRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserRedisRepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserRedisRepositoryMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("UserRedisRepositoryMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &UserRedisRepositoryMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteUser
}

// ExpectIdParam2 sets up expected param id for UserRedisRepository.DeleteUser
func (mmDeleteUser *mUserRedisRepositoryMockDeleteUser) ExpectIdParam2(id int64) *mUserRedisRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserRedisRepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserRedisRepositoryMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("UserRedisRepositoryMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &UserRedisRepositoryMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.id = &id
	mmDeleteUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the UserRedisRepository.DeleteUser
func (mmDeleteUser *mUserRedisRepositoryMockDeleteUser) Inspect(f func(ctx context.Context, id int64)) *mUserRedisRepositoryMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for UserRedisRepositoryMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by UserRedisRepository.DeleteUser
func (mmDeleteUser *mUserRedisRepositoryMockDeleteUser) Return(err error) *UserRedisRepositoryMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserRedisRepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserRedisRepositoryMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &UserRedisRepositoryMockDeleteUserResults{err}
	mmDeleteUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// Set uses given function f to mock the UserRedisRepository.DeleteUser method
func (mmDeleteUser *mUserRedisRepositoryMockDeleteUser) Set(f func(ctx context.Context, id int64) (err error)) *UserRedisRepositoryMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the UserRedisRepository.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the UserRedisRepository.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	mmDeleteUser.mock.funcDeleteUserOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// When sets expectation for the UserRedisRepository.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mUserRedisRepositoryMockDeleteUser) When(ctx context.Context, id int64) *UserRedisRepositoryMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserRedisRepositoryMock.DeleteUser mock is already set by Set")
	}

	expectation := &UserRedisRepositoryMockDeleteUserExpectation{
		mock:               mmDeleteUser.mock,
		params:             &UserRedisRepositoryMockDeleteUserParams{ctx, id},
		expectationOrigins: UserRedisRepositoryMockDeleteUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up UserRedisRepository.DeleteUser return parameters for the expectation previously defined by the When method
func (e *UserRedisRepositoryMockDeleteUserExpectation) Then(err error) *UserRedisRepositoryMock {
	e.results = &UserRedisRepositoryMockDeleteUserResults{err}
	return e.mock
}

// Times sets number of times UserRedisRepository.DeleteUser should be invoked
func (mmDeleteUser *mUserRedisRepositoryMockDeleteUser) Times(n uint64) *mUserRedisRepositoryMockDeleteUser {
	if n == 0 {
		mmDeleteUser.mock.t.Fatalf("Times of UserRedisRepositoryMock.DeleteUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUser.expectedInvocations, n)
	mmDeleteUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteUser
}

func (mmDeleteUser *mUserRedisRepositoryMockDeleteUser) invocationsDone() bool {
	if len(mmDeleteUser.expectations) == 0 && mmDeleteUser.defaultExpectation == nil && mmDeleteUser.mock.funcDeleteUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUser.mock.afterDeleteUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUser implements mm_repository.UserRedisRepository
func (mmDeleteUser *UserRedisRepositoryMock) DeleteUser(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	mmDeleteUser.t.Helper()

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, id)
	}

	mm_params := UserRedisRepositoryMockDeleteUserParams{ctx, id}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

		mm_got := UserRedisRepositoryMockDeleteUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUser.t.Errorf("UserRedisRepositoryMock.DeleteUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteUser.t.Errorf("UserRedisRepositoryMock.DeleteUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("UserRedisRepositoryMock.DeleteUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the UserRedisRepositoryMock.DeleteUser")
		}
		return (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, id)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to UserRedisRepositoryMock.DeleteUser. %v %v", ctx, id)
	return
}

// DeleteUserAfterCounter returns a count of finished UserRedisRepositoryMock.DeleteUser invocations
func (mmDeleteUser *UserRedisRepositoryMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of UserRedisRepositoryMock.DeleteUser invocations
func (mmDeleteUser *UserRedisRepositoryMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to UserRedisRepositoryMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mUserRedisRepositoryMockDeleteUser) Calls() []*UserRedisRepositoryMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*UserRedisRepositoryMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *UserRedisRepositoryMock) MinimockDeleteUserDone() bool {
	if m.DeleteUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserMock.invocationsDone()
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *UserRedisRepositoryMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRedisRepositoryMock.DeleteUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteUserCounter := mm_atomic.LoadUint64(&m.afterDeleteUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && afterDeleteUserCounter < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRedisRepositoryMock.DeleteUser at\n%s", m.DeleteUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRedisRepositoryMock.DeleteUser at\n%s with params: %#v", m.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && afterDeleteUserCounter < 1 {
		m.t.Errorf("Expected call to UserRedisRepositoryMock.DeleteUser at\n%s", m.funcDeleteUserOrigin)
	}

	if !m.DeleteUserMock.invocationsDone() && afterDeleteUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRedisRepositoryMock.DeleteUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserMock.expectedInvocations), m.DeleteUserMock.expectedInvocationsOrigin, afterDeleteUserCounter)
	}
}

type mUserRedisRepositoryMockGetUser struct {
	optional           bool
	mock               *UserRedisRepositoryMock
	defaultExpectation *UserRedisRepositoryMockGetUserExpectation
	expectations       []*UserRedisRepositoryMockGetUserExpectation

	callArgs []*UserRedisRepositoryMockGetUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRedisRepositoryMockGetUserExpectation specifies expectation struct of the UserRedisRepository.GetUser
type UserRedisRepositoryMockGetUserExpectation struct {
	mock               *UserRedisRepositoryMock
	params             *UserRedisRepositoryMockGetUserParams
	paramPtrs          *UserRedisRepositoryMockGetUserParamPtrs
	expectationOrigins UserRedisRepositoryMockGetUserExpectationOrigins
	results            *UserRedisRepositoryMockGetUserResults
	returnOrigin       string
	Counter            uint64
}

// UserRedisRepositoryMockGetUserParams contains parameters of the UserRedisRepository.GetUser
type UserRedisRepositoryMockGetUserParams struct {
	ctx context.Context
	id  int64
}

// UserRedisRepositoryMockGetUserParamPtrs contains pointers to parameters of the UserRedisRepository.GetUser
type UserRedisRepositoryMockGetUserParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserRedisRepositoryMockGetUserResults contains results of the UserRedisRepository.GetUser
type UserRedisRepositoryMockGetUserResults struct {
	up1 *model.User
	err error
}

// UserRedisRepositoryMockGetUserOrigins contains origins of expectations of the UserRedisRepository.GetUser
type UserRedisRepositoryMockGetUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mUserRedisRepositoryMockGetUser) Optional() *mUserRedisRepositoryMockGetUser {
	mmGetUser.optional = true
	return mmGetUser
}

// Expect sets up expected params for UserRedisRepository.GetUser
func (mmGetUser *mUserRedisRepositoryMockGetUser) Expect(ctx context.Context, id int64) *mUserRedisRepositoryMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserRedisRepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserRedisRepositoryMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.paramPtrs != nil {
		mmGetUser.mock.t.Fatalf("UserRedisRepositoryMock.GetUser mock is already set by ExpectParams functions")
	}

	mmGetUser.defaultExpectation.params = &UserRedisRepositoryMockGetUserParams{ctx, id}
	mmGetUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// ExpectCtxParam1 sets up expected param ctx for UserRedisRepository.GetUser
func (mmGetUser *mUserRedisRepositoryMockGetUser) ExpectCtxParam1(ctx context.Context) *mUserRedisRepositoryMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserRedisRepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserRedisRepositoryMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("UserRedisRepositoryMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &UserRedisRepositoryMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUser
}

// ExpectIdParam2 sets up expected param id for UserRedisRepository.GetUser
func (mmGetUser *mUserRedisRepositoryMockGetUser) ExpectIdParam2(id int64) *mUserRedisRepositoryMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserRedisRepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserRedisRepositoryMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("UserRedisRepositoryMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &UserRedisRepositoryMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.id = &id
	mmGetUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the UserRedisRepository.GetUser
func (mmGetUser *mUserRedisRepositoryMockGetUser) Inspect(f func(ctx context.Context, id int64)) *mUserRedisRepositoryMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for UserRedisRepositoryMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by UserRedisRepository.GetUser
func (mmGetUser *mUserRedisRepositoryMockGetUser) Return(up1 *model.User, err error) *UserRedisRepositoryMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserRedisRepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserRedisRepositoryMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &UserRedisRepositoryMockGetUserResults{up1, err}
	mmGetUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// Set uses given function f to mock the UserRedisRepository.GetUser method
func (mmGetUser *mUserRedisRepositoryMockGetUser) Set(f func(ctx context.Context, id int64) (up1 *model.User, err error)) *UserRedisRepositoryMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the UserRedisRepository.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the UserRedisRepository.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	mmGetUser.mock.funcGetUserOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// When sets expectation for the UserRedisRepository.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mUserRedisRepositoryMockGetUser) When(ctx context.Context, id int64) *UserRedisRepositoryMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserRedisRepositoryMock.GetUser mock is already set by Set")
	}

	expectation := &UserRedisRepositoryMockGetUserExpectation{
		mock:               mmGetUser.mock,
		params:             &UserRedisRepositoryMockGetUserParams{ctx, id},
		expectationOrigins: UserRedisRepositoryMockGetUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up UserRedisRepository.GetUser return parameters for the expectation previously defined by the When method
func (e *UserRedisRepositoryMockGetUserExpectation) Then(up1 *model.User, err error) *UserRedisRepositoryMock {
	e.results = &UserRedisRepositoryMockGetUserResults{up1, err}
	return e.mock
}

// Times sets number of times UserRedisRepository.GetUser should be invoked
func (mmGetUser *mUserRedisRepositoryMockGetUser) Times(n uint64) *mUserRedisRepositoryMockGetUser {
	if n == 0 {
		mmGetUser.mock.t.Fatalf("Times of UserRedisRepositoryMock.GetUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUser.expectedInvocations, n)
	mmGetUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUser
}

func (mmGetUser *mUserRedisRepositoryMockGetUser) invocationsDone() bool {
	if len(mmGetUser.expectations) == 0 && mmGetUser.defaultExpectation == nil && mmGetUser.mock.funcGetUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUser.mock.afterGetUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUser implements mm_repository.UserRedisRepository
func (mmGetUser *UserRedisRepositoryMock) GetUser(ctx context.Context, id int64) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	mmGetUser.t.Helper()

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, id)
	}

	mm_params := UserRedisRepositoryMockGetUserParams{ctx, id}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

		mm_got := UserRedisRepositoryMockGetUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUser.t.Errorf("UserRedisRepositoryMock.GetUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetUser.t.Errorf("UserRedisRepositoryMock.GetUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("UserRedisRepositoryMock.GetUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the UserRedisRepositoryMock.GetUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, id)
	}
	mmGetUser.t.Fatalf("Unexpected call to UserRedisRepositoryMock.GetUser. %v %v", ctx, id)
	return
}

// GetUserAfterCounter returns a count of finished UserRedisRepositoryMock.GetUser invocations
func (mmGetUser *UserRedisRepositoryMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of UserRedisRepositoryMock.GetUser invocations
func (mmGetUser *UserRedisRepositoryMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to UserRedisRepositoryMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mUserRedisRepositoryMockGetUser) Calls() []*UserRedisRepositoryMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*UserRedisRepositoryMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *UserRedisRepositoryMock) MinimockGetUserDone() bool {
	if m.GetUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserMock.invocationsDone()
}

// MinimockGetUserInspect logs each unmet expectation
func (m *UserRedisRepositoryMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRedisRepositoryMock.GetUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserCounter := mm_atomic.LoadUint64(&m.afterGetUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && afterGetUserCounter < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRedisRepositoryMock.GetUser at\n%s", m.GetUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRedisRepositoryMock.GetUser at\n%s with params: %#v", m.GetUserMock.defaultExpectation.expectationOrigins.origin, *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && afterGetUserCounter < 1 {
		m.t.Errorf("Expected call to UserRedisRepositoryMock.GetUser at\n%s", m.funcGetUserOrigin)
	}

	if !m.GetUserMock.invocationsDone() && afterGetUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRedisRepositoryMock.GetUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserMock.expectedInvocations), m.GetUserMock.expectedInvocationsOrigin, afterGetUserCounter)
	}
}

type mUserRedisRepositoryMockSetExpireUser struct {
	optional           bool
	mock               *UserRedisRepositoryMock
	defaultExpectation *UserRedisRepositoryMockSetExpireUserExpectation
	expectations       []*UserRedisRepositoryMockSetExpireUserExpectation

	callArgs []*UserRedisRepositoryMockSetExpireUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRedisRepositoryMockSetExpireUserExpectation specifies expectation struct of the UserRedisRepository.SetExpireUser
type UserRedisRepositoryMockSetExpireUserExpectation struct {
	mock               *UserRedisRepositoryMock
	params             *UserRedisRepositoryMockSetExpireUserParams
	paramPtrs          *UserRedisRepositoryMockSetExpireUserParamPtrs
	expectationOrigins UserRedisRepositoryMockSetExpireUserExpectationOrigins
	results            *UserRedisRepositoryMockSetExpireUserResults
	returnOrigin       string
	Counter            uint64
}

// UserRedisRepositoryMockSetExpireUserParams contains parameters of the UserRedisRepository.SetExpireUser
type UserRedisRepositoryMockSetExpireUserParams struct {
	ctx context.Context
	id  int64
}

// UserRedisRepositoryMockSetExpireUserParamPtrs contains pointers to parameters of the UserRedisRepository.SetExpireUser
type UserRedisRepositoryMockSetExpireUserParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserRedisRepositoryMockSetExpireUserResults contains results of the UserRedisRepository.SetExpireUser
type UserRedisRepositoryMockSetExpireUserResults struct {
	err error
}

// UserRedisRepositoryMockSetExpireUserOrigins contains origins of expectations of the UserRedisRepository.SetExpireUser
type UserRedisRepositoryMockSetExpireUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetExpireUser *mUserRedisRepositoryMockSetExpireUser) Optional() *mUserRedisRepositoryMockSetExpireUser {
	mmSetExpireUser.optional = true
	return mmSetExpireUser
}

// Expect sets up expected params for UserRedisRepository.SetExpireUser
func (mmSetExpireUser *mUserRedisRepositoryMockSetExpireUser) Expect(ctx context.Context, id int64) *mUserRedisRepositoryMockSetExpireUser {
	if mmSetExpireUser.mock.funcSetExpireUser != nil {
		mmSetExpireUser.mock.t.Fatalf("UserRedisRepositoryMock.SetExpireUser mock is already set by Set")
	}

	if mmSetExpireUser.defaultExpectation == nil {
		mmSetExpireUser.defaultExpectation = &UserRedisRepositoryMockSetExpireUserExpectation{}
	}

	if mmSetExpireUser.defaultExpectation.paramPtrs != nil {
		mmSetExpireUser.mock.t.Fatalf("UserRedisRepositoryMock.SetExpireUser mock is already set by ExpectParams functions")
	}

	mmSetExpireUser.defaultExpectation.params = &UserRedisRepositoryMockSetExpireUserParams{ctx, id}
	mmSetExpireUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetExpireUser.expectations {
		if minimock.Equal(e.params, mmSetExpireUser.defaultExpectation.params) {
			mmSetExpireUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetExpireUser.defaultExpectation.params)
		}
	}

	return mmSetExpireUser
}

// ExpectCtxParam1 sets up expected param ctx for UserRedisRepository.SetExpireUser
func (mmSetExpireUser *mUserRedisRepositoryMockSetExpireUser) ExpectCtxParam1(ctx context.Context) *mUserRedisRepositoryMockSetExpireUser {
	if mmSetExpireUser.mock.funcSetExpireUser != nil {
		mmSetExpireUser.mock.t.Fatalf("UserRedisRepositoryMock.SetExpireUser mock is already set by Set")
	}

	if mmSetExpireUser.defaultExpectation == nil {
		mmSetExpireUser.defaultExpectation = &UserRedisRepositoryMockSetExpireUserExpectation{}
	}

	if mmSetExpireUser.defaultExpectation.params != nil {
		mmSetExpireUser.mock.t.Fatalf("UserRedisRepositoryMock.SetExpireUser mock is already set by Expect")
	}

	if mmSetExpireUser.defaultExpectation.paramPtrs == nil {
		mmSetExpireUser.defaultExpectation.paramPtrs = &UserRedisRepositoryMockSetExpireUserParamPtrs{}
	}
	mmSetExpireUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetExpireUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetExpireUser
}

// ExpectIdParam2 sets up expected param id for UserRedisRepository.SetExpireUser
func (mmSetExpireUser *mUserRedisRepositoryMockSetExpireUser) ExpectIdParam2(id int64) *mUserRedisRepositoryMockSetExpireUser {
	if mmSetExpireUser.mock.funcSetExpireUser != nil {
		mmSetExpireUser.mock.t.Fatalf("UserRedisRepositoryMock.SetExpireUser mock is already set by Set")
	}

	if mmSetExpireUser.defaultExpectation == nil {
		mmSetExpireUser.defaultExpectation = &UserRedisRepositoryMockSetExpireUserExpectation{}
	}

	if mmSetExpireUser.defaultExpectation.params != nil {
		mmSetExpireUser.mock.t.Fatalf("UserRedisRepositoryMock.SetExpireUser mock is already set by Expect")
	}

	if mmSetExpireUser.defaultExpectation.paramPtrs == nil {
		mmSetExpireUser.defaultExpectation.paramPtrs = &UserRedisRepositoryMockSetExpireUserParamPtrs{}
	}
	mmSetExpireUser.defaultExpectation.paramPtrs.id = &id
	mmSetExpireUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmSetExpireUser
}

// Inspect accepts an inspector function that has same arguments as the UserRedisRepository.SetExpireUser
func (mmSetExpireUser *mUserRedisRepositoryMockSetExpireUser) Inspect(f func(ctx context.Context, id int64)) *mUserRedisRepositoryMockSetExpireUser {
	if mmSetExpireUser.mock.inspectFuncSetExpireUser != nil {
		mmSetExpireUser.mock.t.Fatalf("Inspect function is already set for UserRedisRepositoryMock.SetExpireUser")
	}

	mmSetExpireUser.mock.inspectFuncSetExpireUser = f

	return mmSetExpireUser
}

// Return sets up results that will be returned by UserRedisRepository.SetExpireUser
func (mmSetExpireUser *mUserRedisRepositoryMockSetExpireUser) Return(err error) *UserRedisRepositoryMock {
	if mmSetExpireUser.mock.funcSetExpireUser != nil {
		mmSetExpireUser.mock.t.Fatalf("UserRedisRepositoryMock.SetExpireUser mock is already set by Set")
	}

	if mmSetExpireUser.defaultExpectation == nil {
		mmSetExpireUser.defaultExpectation = &UserRedisRepositoryMockSetExpireUserExpectation{mock: mmSetExpireUser.mock}
	}
	mmSetExpireUser.defaultExpectation.results = &UserRedisRepositoryMockSetExpireUserResults{err}
	mmSetExpireUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetExpireUser.mock
}

// Set uses given function f to mock the UserRedisRepository.SetExpireUser method
func (mmSetExpireUser *mUserRedisRepositoryMockSetExpireUser) Set(f func(ctx context.Context, id int64) (err error)) *UserRedisRepositoryMock {
	if mmSetExpireUser.defaultExpectation != nil {
		mmSetExpireUser.mock.t.Fatalf("Default expectation is already set for the UserRedisRepository.SetExpireUser method")
	}

	if len(mmSetExpireUser.expectations) > 0 {
		mmSetExpireUser.mock.t.Fatalf("Some expectations are already set for the UserRedisRepository.SetExpireUser method")
	}

	mmSetExpireUser.mock.funcSetExpireUser = f
	mmSetExpireUser.mock.funcSetExpireUserOrigin = minimock.CallerInfo(1)
	return mmSetExpireUser.mock
}

// When sets expectation for the UserRedisRepository.SetExpireUser which will trigger the result defined by the following
// Then helper
func (mmSetExpireUser *mUserRedisRepositoryMockSetExpireUser) When(ctx context.Context, id int64) *UserRedisRepositoryMockSetExpireUserExpectation {
	if mmSetExpireUser.mock.funcSetExpireUser != nil {
		mmSetExpireUser.mock.t.Fatalf("UserRedisRepositoryMock.SetExpireUser mock is already set by Set")
	}

	expectation := &UserRedisRepositoryMockSetExpireUserExpectation{
		mock:               mmSetExpireUser.mock,
		params:             &UserRedisRepositoryMockSetExpireUserParams{ctx, id},
		expectationOrigins: UserRedisRepositoryMockSetExpireUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetExpireUser.expectations = append(mmSetExpireUser.expectations, expectation)
	return expectation
}

// Then sets up UserRedisRepository.SetExpireUser return parameters for the expectation previously defined by the When method
func (e *UserRedisRepositoryMockSetExpireUserExpectation) Then(err error) *UserRedisRepositoryMock {
	e.results = &UserRedisRepositoryMockSetExpireUserResults{err}
	return e.mock
}

// Times sets number of times UserRedisRepository.SetExpireUser should be invoked
func (mmSetExpireUser *mUserRedisRepositoryMockSetExpireUser) Times(n uint64) *mUserRedisRepositoryMockSetExpireUser {
	if n == 0 {
		mmSetExpireUser.mock.t.Fatalf("Times of UserRedisRepositoryMock.SetExpireUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetExpireUser.expectedInvocations, n)
	mmSetExpireUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetExpireUser
}

func (mmSetExpireUser *mUserRedisRepositoryMockSetExpireUser) invocationsDone() bool {
	if len(mmSetExpireUser.expectations) == 0 && mmSetExpireUser.defaultExpectation == nil && mmSetExpireUser.mock.funcSetExpireUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetExpireUser.mock.afterSetExpireUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetExpireUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetExpireUser implements mm_repository.UserRedisRepository
func (mmSetExpireUser *UserRedisRepositoryMock) SetExpireUser(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmSetExpireUser.beforeSetExpireUserCounter, 1)
	defer mm_atomic.AddUint64(&mmSetExpireUser.afterSetExpireUserCounter, 1)

	mmSetExpireUser.t.Helper()

	if mmSetExpireUser.inspectFuncSetExpireUser != nil {
		mmSetExpireUser.inspectFuncSetExpireUser(ctx, id)
	}

	mm_params := UserRedisRepositoryMockSetExpireUserParams{ctx, id}

	// Record call args
	mmSetExpireUser.SetExpireUserMock.mutex.Lock()
	mmSetExpireUser.SetExpireUserMock.callArgs = append(mmSetExpireUser.SetExpireUserMock.callArgs, &mm_params)
	mmSetExpireUser.SetExpireUserMock.mutex.Unlock()

	for _, e := range mmSetExpireUser.SetExpireUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetExpireUser.SetExpireUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetExpireUser.SetExpireUserMock.defaultExpectation.Counter, 1)
		mm_want := mmSetExpireUser.SetExpireUserMock.defaultExpectation.params
		mm_want_ptrs := mmSetExpireUser.SetExpireUserMock.defaultExpectation.paramPtrs

		mm_got := UserRedisRepositoryMockSetExpireUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetExpireUser.t.Errorf("UserRedisRepositoryMock.SetExpireUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetExpireUser.SetExpireUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmSetExpireUser.t.Errorf("UserRedisRepositoryMock.SetExpireUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetExpireUser.SetExpireUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetExpireUser.t.Errorf("UserRedisRepositoryMock.SetExpireUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetExpireUser.SetExpireUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetExpireUser.SetExpireUserMock.defaultExpectation.results
		if mm_results == nil {
			mmSetExpireUser.t.Fatal("No results are set for the UserRedisRepositoryMock.SetExpireUser")
		}
		return (*mm_results).err
	}
	if mmSetExpireUser.funcSetExpireUser != nil {
		return mmSetExpireUser.funcSetExpireUser(ctx, id)
	}
	mmSetExpireUser.t.Fatalf("Unexpected call to UserRedisRepositoryMock.SetExpireUser. %v %v", ctx, id)
	return
}

// SetExpireUserAfterCounter returns a count of finished UserRedisRepositoryMock.SetExpireUser invocations
func (mmSetExpireUser *UserRedisRepositoryMock) SetExpireUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetExpireUser.afterSetExpireUserCounter)
}

// SetExpireUserBeforeCounter returns a count of UserRedisRepositoryMock.SetExpireUser invocations
func (mmSetExpireUser *UserRedisRepositoryMock) SetExpireUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetExpireUser.beforeSetExpireUserCounter)
}

// Calls returns a list of arguments used in each call to UserRedisRepositoryMock.SetExpireUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetExpireUser *mUserRedisRepositoryMockSetExpireUser) Calls() []*UserRedisRepositoryMockSetExpireUserParams {
	mmSetExpireUser.mutex.RLock()

	argCopy := make([]*UserRedisRepositoryMockSetExpireUserParams, len(mmSetExpireUser.callArgs))
	copy(argCopy, mmSetExpireUser.callArgs)

	mmSetExpireUser.mutex.RUnlock()

	return argCopy
}

// MinimockSetExpireUserDone returns true if the count of the SetExpireUser invocations corresponds
// the number of defined expectations
func (m *UserRedisRepositoryMock) MinimockSetExpireUserDone() bool {
	if m.SetExpireUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetExpireUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetExpireUserMock.invocationsDone()
}

// MinimockSetExpireUserInspect logs each unmet expectation
func (m *UserRedisRepositoryMock) MinimockSetExpireUserInspect() {
	for _, e := range m.SetExpireUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRedisRepositoryMock.SetExpireUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetExpireUserCounter := mm_atomic.LoadUint64(&m.afterSetExpireUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetExpireUserMock.defaultExpectation != nil && afterSetExpireUserCounter < 1 {
		if m.SetExpireUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRedisRepositoryMock.SetExpireUser at\n%s", m.SetExpireUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRedisRepositoryMock.SetExpireUser at\n%s with params: %#v", m.SetExpireUserMock.defaultExpectation.expectationOrigins.origin, *m.SetExpireUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetExpireUser != nil && afterSetExpireUserCounter < 1 {
		m.t.Errorf("Expected call to UserRedisRepositoryMock.SetExpireUser at\n%s", m.funcSetExpireUserOrigin)
	}

	if !m.SetExpireUserMock.invocationsDone() && afterSetExpireUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRedisRepositoryMock.SetExpireUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetExpireUserMock.expectedInvocations), m.SetExpireUserMock.expectedInvocationsOrigin, afterSetExpireUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserRedisRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateUserInspect()

			m.MinimockDeleteUserInspect()

			m.MinimockGetUserInspect()

			m.MinimockSetExpireUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserRedisRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserRedisRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockGetUserDone() &&
		m.MinimockSetExpireUserDone()
}
