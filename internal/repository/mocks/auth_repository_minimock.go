// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/valek177/auth/internal/repository.AuthRepository -o auth_repository_minimock.go -n AuthRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/valek177/auth/internal/model"
)

// AuthRepositoryMock implements mm_repository.AuthRepository
type AuthRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateUser          func(ctx context.Context, newUser *model.NewUser) (i1 int64, err error)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(ctx context.Context, newUser *model.NewUser)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mAuthRepositoryMockCreateUser

	funcDeleteUser          func(ctx context.Context, id int64) (err error)
	funcDeleteUserOrigin    string
	inspectFuncDeleteUser   func(ctx context.Context, id int64)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mAuthRepositoryMockDeleteUser

	funcGetUser          func(ctx context.Context, id int64) (up1 *model.User, err error)
	funcGetUserOrigin    string
	inspectFuncGetUser   func(ctx context.Context, id int64)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mAuthRepositoryMockGetUser

	funcUpdateUser          func(ctx context.Context, updateUserInfo *model.UpdateUserInfo) (err error)
	funcUpdateUserOrigin    string
	inspectFuncUpdateUser   func(ctx context.Context, updateUserInfo *model.UpdateUserInfo)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mAuthRepositoryMockUpdateUser
}

// NewAuthRepositoryMock returns a mock for mm_repository.AuthRepository
func NewAuthRepositoryMock(t minimock.Tester) *AuthRepositoryMock {
	m := &AuthRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateUserMock = mAuthRepositoryMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*AuthRepositoryMockCreateUserParams{}

	m.DeleteUserMock = mAuthRepositoryMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*AuthRepositoryMockDeleteUserParams{}

	m.GetUserMock = mAuthRepositoryMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*AuthRepositoryMockGetUserParams{}

	m.UpdateUserMock = mAuthRepositoryMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*AuthRepositoryMockUpdateUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAuthRepositoryMockCreateUser struct {
	optional           bool
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockCreateUserExpectation
	expectations       []*AuthRepositoryMockCreateUserExpectation

	callArgs []*AuthRepositoryMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthRepositoryMockCreateUserExpectation specifies expectation struct of the AuthRepository.CreateUser
type AuthRepositoryMockCreateUserExpectation struct {
	mock               *AuthRepositoryMock
	params             *AuthRepositoryMockCreateUserParams
	paramPtrs          *AuthRepositoryMockCreateUserParamPtrs
	expectationOrigins AuthRepositoryMockCreateUserExpectationOrigins
	results            *AuthRepositoryMockCreateUserResults
	returnOrigin       string
	Counter            uint64
}

// AuthRepositoryMockCreateUserParams contains parameters of the AuthRepository.CreateUser
type AuthRepositoryMockCreateUserParams struct {
	ctx     context.Context
	newUser *model.NewUser
}

// AuthRepositoryMockCreateUserParamPtrs contains pointers to parameters of the AuthRepository.CreateUser
type AuthRepositoryMockCreateUserParamPtrs struct {
	ctx     *context.Context
	newUser **model.NewUser
}

// AuthRepositoryMockCreateUserResults contains results of the AuthRepository.CreateUser
type AuthRepositoryMockCreateUserResults struct {
	i1  int64
	err error
}

// AuthRepositoryMockCreateUserOrigins contains origins of expectations of the AuthRepository.CreateUser
type AuthRepositoryMockCreateUserExpectationOrigins struct {
	origin        string
	originCtx     string
	originNewUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mAuthRepositoryMockCreateUser) Optional() *mAuthRepositoryMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for AuthRepository.CreateUser
func (mmCreateUser *mAuthRepositoryMockCreateUser) Expect(ctx context.Context, newUser *model.NewUser) *mAuthRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &AuthRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &AuthRepositoryMockCreateUserParams{ctx, newUser}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for AuthRepository.CreateUser
func (mmCreateUser *mAuthRepositoryMockCreateUser) ExpectCtxParam1(ctx context.Context) *mAuthRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &AuthRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &AuthRepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectNewUserParam2 sets up expected param newUser for AuthRepository.CreateUser
func (mmCreateUser *mAuthRepositoryMockCreateUser) ExpectNewUserParam2(newUser *model.NewUser) *mAuthRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &AuthRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &AuthRepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.newUser = &newUser
	mmCreateUser.defaultExpectation.expectationOrigins.originNewUser = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.CreateUser
func (mmCreateUser *mAuthRepositoryMockCreateUser) Inspect(f func(ctx context.Context, newUser *model.NewUser)) *mAuthRepositoryMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by AuthRepository.CreateUser
func (mmCreateUser *mAuthRepositoryMockCreateUser) Return(i1 int64, err error) *AuthRepositoryMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &AuthRepositoryMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &AuthRepositoryMockCreateUserResults{i1, err}
	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the AuthRepository.CreateUser method
func (mmCreateUser *mAuthRepositoryMockCreateUser) Set(f func(ctx context.Context, newUser *model.NewUser) (i1 int64, err error)) *AuthRepositoryMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the AuthRepository.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the AuthRepository.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the AuthRepository.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mAuthRepositoryMockCreateUser) When(ctx context.Context, newUser *model.NewUser) *AuthRepositoryMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Set")
	}

	expectation := &AuthRepositoryMockCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &AuthRepositoryMockCreateUserParams{ctx, newUser},
		expectationOrigins: AuthRepositoryMockCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.CreateUser return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockCreateUserExpectation) Then(i1 int64, err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockCreateUserResults{i1, err}
	return e.mock
}

// Times sets number of times AuthRepository.CreateUser should be invoked
func (mmCreateUser *mAuthRepositoryMockCreateUser) Times(n uint64) *mAuthRepositoryMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of AuthRepositoryMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mAuthRepositoryMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_repository.AuthRepository
func (mmCreateUser *AuthRepositoryMock) CreateUser(ctx context.Context, newUser *model.NewUser) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, newUser)
	}

	mm_params := AuthRepositoryMockCreateUserParams{ctx, newUser}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := AuthRepositoryMockCreateUserParams{ctx, newUser}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("AuthRepositoryMock.CreateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.newUser != nil && !minimock.Equal(*mm_want_ptrs.newUser, mm_got.newUser) {
				mmCreateUser.t.Errorf("AuthRepositoryMock.CreateUser got unexpected parameter newUser, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originNewUser, *mm_want_ptrs.newUser, mm_got.newUser, minimock.Diff(*mm_want_ptrs.newUser, mm_got.newUser))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("AuthRepositoryMock.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the AuthRepositoryMock.CreateUser")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, newUser)
	}
	mmCreateUser.t.Fatalf("Unexpected call to AuthRepositoryMock.CreateUser. %v %v", ctx, newUser)
	return
}

// CreateUserAfterCounter returns a count of finished AuthRepositoryMock.CreateUser invocations
func (mmCreateUser *AuthRepositoryMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of AuthRepositoryMock.CreateUser invocations
func (mmCreateUser *AuthRepositoryMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mAuthRepositoryMockCreateUser) Calls() []*AuthRepositoryMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthRepositoryMock.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to AuthRepositoryMock.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthRepositoryMock.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mAuthRepositoryMockDeleteUser struct {
	optional           bool
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockDeleteUserExpectation
	expectations       []*AuthRepositoryMockDeleteUserExpectation

	callArgs []*AuthRepositoryMockDeleteUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthRepositoryMockDeleteUserExpectation specifies expectation struct of the AuthRepository.DeleteUser
type AuthRepositoryMockDeleteUserExpectation struct {
	mock               *AuthRepositoryMock
	params             *AuthRepositoryMockDeleteUserParams
	paramPtrs          *AuthRepositoryMockDeleteUserParamPtrs
	expectationOrigins AuthRepositoryMockDeleteUserExpectationOrigins
	results            *AuthRepositoryMockDeleteUserResults
	returnOrigin       string
	Counter            uint64
}

// AuthRepositoryMockDeleteUserParams contains parameters of the AuthRepository.DeleteUser
type AuthRepositoryMockDeleteUserParams struct {
	ctx context.Context
	id  int64
}

// AuthRepositoryMockDeleteUserParamPtrs contains pointers to parameters of the AuthRepository.DeleteUser
type AuthRepositoryMockDeleteUserParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// AuthRepositoryMockDeleteUserResults contains results of the AuthRepository.DeleteUser
type AuthRepositoryMockDeleteUserResults struct {
	err error
}

// AuthRepositoryMockDeleteUserOrigins contains origins of expectations of the AuthRepository.DeleteUser
type AuthRepositoryMockDeleteUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mAuthRepositoryMockDeleteUser) Optional() *mAuthRepositoryMockDeleteUser {
	mmDeleteUser.optional = true
	return mmDeleteUser
}

// Expect sets up expected params for AuthRepository.DeleteUser
func (mmDeleteUser *mAuthRepositoryMockDeleteUser) Expect(ctx context.Context, id int64) *mAuthRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("AuthRepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &AuthRepositoryMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.paramPtrs != nil {
		mmDeleteUser.mock.t.Fatalf("AuthRepositoryMock.DeleteUser mock is already set by ExpectParams functions")
	}

	mmDeleteUser.defaultExpectation.params = &AuthRepositoryMockDeleteUserParams{ctx, id}
	mmDeleteUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// ExpectCtxParam1 sets up expected param ctx for AuthRepository.DeleteUser
func (mmDeleteUser *mAuthRepositoryMockDeleteUser) ExpectCtxParam1(ctx context.Context) *mAuthRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("AuthRepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &AuthRepositoryMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("AuthRepositoryMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &AuthRepositoryMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteUser
}

// ExpectIdParam2 sets up expected param id for AuthRepository.DeleteUser
func (mmDeleteUser *mAuthRepositoryMockDeleteUser) ExpectIdParam2(id int64) *mAuthRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("AuthRepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &AuthRepositoryMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("AuthRepositoryMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &AuthRepositoryMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.id = &id
	mmDeleteUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.DeleteUser
func (mmDeleteUser *mAuthRepositoryMockDeleteUser) Inspect(f func(ctx context.Context, id int64)) *mAuthRepositoryMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by AuthRepository.DeleteUser
func (mmDeleteUser *mAuthRepositoryMockDeleteUser) Return(err error) *AuthRepositoryMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("AuthRepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &AuthRepositoryMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &AuthRepositoryMockDeleteUserResults{err}
	mmDeleteUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// Set uses given function f to mock the AuthRepository.DeleteUser method
func (mmDeleteUser *mAuthRepositoryMockDeleteUser) Set(f func(ctx context.Context, id int64) (err error)) *AuthRepositoryMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the AuthRepository.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the AuthRepository.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	mmDeleteUser.mock.funcDeleteUserOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// When sets expectation for the AuthRepository.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mAuthRepositoryMockDeleteUser) When(ctx context.Context, id int64) *AuthRepositoryMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("AuthRepositoryMock.DeleteUser mock is already set by Set")
	}

	expectation := &AuthRepositoryMockDeleteUserExpectation{
		mock:               mmDeleteUser.mock,
		params:             &AuthRepositoryMockDeleteUserParams{ctx, id},
		expectationOrigins: AuthRepositoryMockDeleteUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.DeleteUser return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockDeleteUserExpectation) Then(err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockDeleteUserResults{err}
	return e.mock
}

// Times sets number of times AuthRepository.DeleteUser should be invoked
func (mmDeleteUser *mAuthRepositoryMockDeleteUser) Times(n uint64) *mAuthRepositoryMockDeleteUser {
	if n == 0 {
		mmDeleteUser.mock.t.Fatalf("Times of AuthRepositoryMock.DeleteUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUser.expectedInvocations, n)
	mmDeleteUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteUser
}

func (mmDeleteUser *mAuthRepositoryMockDeleteUser) invocationsDone() bool {
	if len(mmDeleteUser.expectations) == 0 && mmDeleteUser.defaultExpectation == nil && mmDeleteUser.mock.funcDeleteUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUser.mock.afterDeleteUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUser implements mm_repository.AuthRepository
func (mmDeleteUser *AuthRepositoryMock) DeleteUser(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	mmDeleteUser.t.Helper()

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, id)
	}

	mm_params := AuthRepositoryMockDeleteUserParams{ctx, id}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

		mm_got := AuthRepositoryMockDeleteUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUser.t.Errorf("AuthRepositoryMock.DeleteUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteUser.t.Errorf("AuthRepositoryMock.DeleteUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("AuthRepositoryMock.DeleteUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the AuthRepositoryMock.DeleteUser")
		}
		return (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, id)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to AuthRepositoryMock.DeleteUser. %v %v", ctx, id)
	return
}

// DeleteUserAfterCounter returns a count of finished AuthRepositoryMock.DeleteUser invocations
func (mmDeleteUser *AuthRepositoryMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of AuthRepositoryMock.DeleteUser invocations
func (mmDeleteUser *AuthRepositoryMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mAuthRepositoryMockDeleteUser) Calls() []*AuthRepositoryMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockDeleteUserDone() bool {
	if m.DeleteUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserMock.invocationsDone()
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.DeleteUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteUserCounter := mm_atomic.LoadUint64(&m.afterDeleteUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && afterDeleteUserCounter < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthRepositoryMock.DeleteUser at\n%s", m.DeleteUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.DeleteUser at\n%s with params: %#v", m.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && afterDeleteUserCounter < 1 {
		m.t.Errorf("Expected call to AuthRepositoryMock.DeleteUser at\n%s", m.funcDeleteUserOrigin)
	}

	if !m.DeleteUserMock.invocationsDone() && afterDeleteUserCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthRepositoryMock.DeleteUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserMock.expectedInvocations), m.DeleteUserMock.expectedInvocationsOrigin, afterDeleteUserCounter)
	}
}

type mAuthRepositoryMockGetUser struct {
	optional           bool
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockGetUserExpectation
	expectations       []*AuthRepositoryMockGetUserExpectation

	callArgs []*AuthRepositoryMockGetUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthRepositoryMockGetUserExpectation specifies expectation struct of the AuthRepository.GetUser
type AuthRepositoryMockGetUserExpectation struct {
	mock               *AuthRepositoryMock
	params             *AuthRepositoryMockGetUserParams
	paramPtrs          *AuthRepositoryMockGetUserParamPtrs
	expectationOrigins AuthRepositoryMockGetUserExpectationOrigins
	results            *AuthRepositoryMockGetUserResults
	returnOrigin       string
	Counter            uint64
}

// AuthRepositoryMockGetUserParams contains parameters of the AuthRepository.GetUser
type AuthRepositoryMockGetUserParams struct {
	ctx context.Context
	id  int64
}

// AuthRepositoryMockGetUserParamPtrs contains pointers to parameters of the AuthRepository.GetUser
type AuthRepositoryMockGetUserParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// AuthRepositoryMockGetUserResults contains results of the AuthRepository.GetUser
type AuthRepositoryMockGetUserResults struct {
	up1 *model.User
	err error
}

// AuthRepositoryMockGetUserOrigins contains origins of expectations of the AuthRepository.GetUser
type AuthRepositoryMockGetUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mAuthRepositoryMockGetUser) Optional() *mAuthRepositoryMockGetUser {
	mmGetUser.optional = true
	return mmGetUser
}

// Expect sets up expected params for AuthRepository.GetUser
func (mmGetUser *mAuthRepositoryMockGetUser) Expect(ctx context.Context, id int64) *mAuthRepositoryMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("AuthRepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &AuthRepositoryMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.paramPtrs != nil {
		mmGetUser.mock.t.Fatalf("AuthRepositoryMock.GetUser mock is already set by ExpectParams functions")
	}

	mmGetUser.defaultExpectation.params = &AuthRepositoryMockGetUserParams{ctx, id}
	mmGetUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// ExpectCtxParam1 sets up expected param ctx for AuthRepository.GetUser
func (mmGetUser *mAuthRepositoryMockGetUser) ExpectCtxParam1(ctx context.Context) *mAuthRepositoryMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("AuthRepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &AuthRepositoryMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("AuthRepositoryMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &AuthRepositoryMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUser
}

// ExpectIdParam2 sets up expected param id for AuthRepository.GetUser
func (mmGetUser *mAuthRepositoryMockGetUser) ExpectIdParam2(id int64) *mAuthRepositoryMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("AuthRepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &AuthRepositoryMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("AuthRepositoryMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &AuthRepositoryMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.id = &id
	mmGetUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.GetUser
func (mmGetUser *mAuthRepositoryMockGetUser) Inspect(f func(ctx context.Context, id int64)) *mAuthRepositoryMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by AuthRepository.GetUser
func (mmGetUser *mAuthRepositoryMockGetUser) Return(up1 *model.User, err error) *AuthRepositoryMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("AuthRepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &AuthRepositoryMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &AuthRepositoryMockGetUserResults{up1, err}
	mmGetUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// Set uses given function f to mock the AuthRepository.GetUser method
func (mmGetUser *mAuthRepositoryMockGetUser) Set(f func(ctx context.Context, id int64) (up1 *model.User, err error)) *AuthRepositoryMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the AuthRepository.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the AuthRepository.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	mmGetUser.mock.funcGetUserOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// When sets expectation for the AuthRepository.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mAuthRepositoryMockGetUser) When(ctx context.Context, id int64) *AuthRepositoryMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("AuthRepositoryMock.GetUser mock is already set by Set")
	}

	expectation := &AuthRepositoryMockGetUserExpectation{
		mock:               mmGetUser.mock,
		params:             &AuthRepositoryMockGetUserParams{ctx, id},
		expectationOrigins: AuthRepositoryMockGetUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.GetUser return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockGetUserExpectation) Then(up1 *model.User, err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockGetUserResults{up1, err}
	return e.mock
}

// Times sets number of times AuthRepository.GetUser should be invoked
func (mmGetUser *mAuthRepositoryMockGetUser) Times(n uint64) *mAuthRepositoryMockGetUser {
	if n == 0 {
		mmGetUser.mock.t.Fatalf("Times of AuthRepositoryMock.GetUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUser.expectedInvocations, n)
	mmGetUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUser
}

func (mmGetUser *mAuthRepositoryMockGetUser) invocationsDone() bool {
	if len(mmGetUser.expectations) == 0 && mmGetUser.defaultExpectation == nil && mmGetUser.mock.funcGetUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUser.mock.afterGetUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUser implements mm_repository.AuthRepository
func (mmGetUser *AuthRepositoryMock) GetUser(ctx context.Context, id int64) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	mmGetUser.t.Helper()

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, id)
	}

	mm_params := AuthRepositoryMockGetUserParams{ctx, id}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

		mm_got := AuthRepositoryMockGetUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUser.t.Errorf("AuthRepositoryMock.GetUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetUser.t.Errorf("AuthRepositoryMock.GetUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("AuthRepositoryMock.GetUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the AuthRepositoryMock.GetUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, id)
	}
	mmGetUser.t.Fatalf("Unexpected call to AuthRepositoryMock.GetUser. %v %v", ctx, id)
	return
}

// GetUserAfterCounter returns a count of finished AuthRepositoryMock.GetUser invocations
func (mmGetUser *AuthRepositoryMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of AuthRepositoryMock.GetUser invocations
func (mmGetUser *AuthRepositoryMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mAuthRepositoryMockGetUser) Calls() []*AuthRepositoryMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockGetUserDone() bool {
	if m.GetUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserMock.invocationsDone()
}

// MinimockGetUserInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.GetUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserCounter := mm_atomic.LoadUint64(&m.afterGetUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && afterGetUserCounter < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthRepositoryMock.GetUser at\n%s", m.GetUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.GetUser at\n%s with params: %#v", m.GetUserMock.defaultExpectation.expectationOrigins.origin, *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && afterGetUserCounter < 1 {
		m.t.Errorf("Expected call to AuthRepositoryMock.GetUser at\n%s", m.funcGetUserOrigin)
	}

	if !m.GetUserMock.invocationsDone() && afterGetUserCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthRepositoryMock.GetUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserMock.expectedInvocations), m.GetUserMock.expectedInvocationsOrigin, afterGetUserCounter)
	}
}

type mAuthRepositoryMockUpdateUser struct {
	optional           bool
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockUpdateUserExpectation
	expectations       []*AuthRepositoryMockUpdateUserExpectation

	callArgs []*AuthRepositoryMockUpdateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthRepositoryMockUpdateUserExpectation specifies expectation struct of the AuthRepository.UpdateUser
type AuthRepositoryMockUpdateUserExpectation struct {
	mock               *AuthRepositoryMock
	params             *AuthRepositoryMockUpdateUserParams
	paramPtrs          *AuthRepositoryMockUpdateUserParamPtrs
	expectationOrigins AuthRepositoryMockUpdateUserExpectationOrigins
	results            *AuthRepositoryMockUpdateUserResults
	returnOrigin       string
	Counter            uint64
}

// AuthRepositoryMockUpdateUserParams contains parameters of the AuthRepository.UpdateUser
type AuthRepositoryMockUpdateUserParams struct {
	ctx            context.Context
	updateUserInfo *model.UpdateUserInfo
}

// AuthRepositoryMockUpdateUserParamPtrs contains pointers to parameters of the AuthRepository.UpdateUser
type AuthRepositoryMockUpdateUserParamPtrs struct {
	ctx            *context.Context
	updateUserInfo **model.UpdateUserInfo
}

// AuthRepositoryMockUpdateUserResults contains results of the AuthRepository.UpdateUser
type AuthRepositoryMockUpdateUserResults struct {
	err error
}

// AuthRepositoryMockUpdateUserOrigins contains origins of expectations of the AuthRepository.UpdateUser
type AuthRepositoryMockUpdateUserExpectationOrigins struct {
	origin               string
	originCtx            string
	originUpdateUserInfo string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUser *mAuthRepositoryMockUpdateUser) Optional() *mAuthRepositoryMockUpdateUser {
	mmUpdateUser.optional = true
	return mmUpdateUser
}

// Expect sets up expected params for AuthRepository.UpdateUser
func (mmUpdateUser *mAuthRepositoryMockUpdateUser) Expect(ctx context.Context, updateUserInfo *model.UpdateUserInfo) *mAuthRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("AuthRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &AuthRepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.paramPtrs != nil {
		mmUpdateUser.mock.t.Fatalf("AuthRepositoryMock.UpdateUser mock is already set by ExpectParams functions")
	}

	mmUpdateUser.defaultExpectation.params = &AuthRepositoryMockUpdateUserParams{ctx, updateUserInfo}
	mmUpdateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// ExpectCtxParam1 sets up expected param ctx for AuthRepository.UpdateUser
func (mmUpdateUser *mAuthRepositoryMockUpdateUser) ExpectCtxParam1(ctx context.Context) *mAuthRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("AuthRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &AuthRepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("AuthRepositoryMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &AuthRepositoryMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUser
}

// ExpectUpdateUserInfoParam2 sets up expected param updateUserInfo for AuthRepository.UpdateUser
func (mmUpdateUser *mAuthRepositoryMockUpdateUser) ExpectUpdateUserInfoParam2(updateUserInfo *model.UpdateUserInfo) *mAuthRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("AuthRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &AuthRepositoryMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("AuthRepositoryMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &AuthRepositoryMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.updateUserInfo = &updateUserInfo
	mmUpdateUser.defaultExpectation.expectationOrigins.originUpdateUserInfo = minimock.CallerInfo(1)

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.UpdateUser
func (mmUpdateUser *mAuthRepositoryMockUpdateUser) Inspect(f func(ctx context.Context, updateUserInfo *model.UpdateUserInfo)) *mAuthRepositoryMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by AuthRepository.UpdateUser
func (mmUpdateUser *mAuthRepositoryMockUpdateUser) Return(err error) *AuthRepositoryMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("AuthRepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &AuthRepositoryMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &AuthRepositoryMockUpdateUserResults{err}
	mmUpdateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// Set uses given function f to mock the AuthRepository.UpdateUser method
func (mmUpdateUser *mAuthRepositoryMockUpdateUser) Set(f func(ctx context.Context, updateUserInfo *model.UpdateUserInfo) (err error)) *AuthRepositoryMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the AuthRepository.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the AuthRepository.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	mmUpdateUser.mock.funcUpdateUserOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// When sets expectation for the AuthRepository.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mAuthRepositoryMockUpdateUser) When(ctx context.Context, updateUserInfo *model.UpdateUserInfo) *AuthRepositoryMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("AuthRepositoryMock.UpdateUser mock is already set by Set")
	}

	expectation := &AuthRepositoryMockUpdateUserExpectation{
		mock:               mmUpdateUser.mock,
		params:             &AuthRepositoryMockUpdateUserParams{ctx, updateUserInfo},
		expectationOrigins: AuthRepositoryMockUpdateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.UpdateUser return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockUpdateUserExpectation) Then(err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockUpdateUserResults{err}
	return e.mock
}

// Times sets number of times AuthRepository.UpdateUser should be invoked
func (mmUpdateUser *mAuthRepositoryMockUpdateUser) Times(n uint64) *mAuthRepositoryMockUpdateUser {
	if n == 0 {
		mmUpdateUser.mock.t.Fatalf("Times of AuthRepositoryMock.UpdateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUser.expectedInvocations, n)
	mmUpdateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUser
}

func (mmUpdateUser *mAuthRepositoryMockUpdateUser) invocationsDone() bool {
	if len(mmUpdateUser.expectations) == 0 && mmUpdateUser.defaultExpectation == nil && mmUpdateUser.mock.funcUpdateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUser.mock.afterUpdateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUser implements mm_repository.AuthRepository
func (mmUpdateUser *AuthRepositoryMock) UpdateUser(ctx context.Context, updateUserInfo *model.UpdateUserInfo) (err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	mmUpdateUser.t.Helper()

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(ctx, updateUserInfo)
	}

	mm_params := AuthRepositoryMockUpdateUserParams{ctx, updateUserInfo}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, &mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUser.UpdateUserMock.defaultExpectation.paramPtrs

		mm_got := AuthRepositoryMockUpdateUserParams{ctx, updateUserInfo}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUser.t.Errorf("AuthRepositoryMock.UpdateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.updateUserInfo != nil && !minimock.Equal(*mm_want_ptrs.updateUserInfo, mm_got.updateUserInfo) {
				mmUpdateUser.t.Errorf("AuthRepositoryMock.UpdateUser got unexpected parameter updateUserInfo, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originUpdateUserInfo, *mm_want_ptrs.updateUserInfo, mm_got.updateUserInfo, minimock.Diff(*mm_want_ptrs.updateUserInfo, mm_got.updateUserInfo))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("AuthRepositoryMock.UpdateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the AuthRepositoryMock.UpdateUser")
		}
		return (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(ctx, updateUserInfo)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to AuthRepositoryMock.UpdateUser. %v %v", ctx, updateUserInfo)
	return
}

// UpdateUserAfterCounter returns a count of finished AuthRepositoryMock.UpdateUser invocations
func (mmUpdateUser *AuthRepositoryMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of AuthRepositoryMock.UpdateUser invocations
func (mmUpdateUser *AuthRepositoryMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mAuthRepositoryMockUpdateUser) Calls() []*AuthRepositoryMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockUpdateUserDone() bool {
	if m.UpdateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserMock.invocationsDone()
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.UpdateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserCounter := mm_atomic.LoadUint64(&m.afterUpdateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && afterUpdateUserCounter < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthRepositoryMock.UpdateUser at\n%s", m.UpdateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.UpdateUser at\n%s with params: %#v", m.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && afterUpdateUserCounter < 1 {
		m.t.Errorf("Expected call to AuthRepositoryMock.UpdateUser at\n%s", m.funcUpdateUserOrigin)
	}

	if !m.UpdateUserMock.invocationsDone() && afterUpdateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthRepositoryMock.UpdateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserMock.expectedInvocations), m.UpdateUserMock.expectedInvocationsOrigin, afterUpdateUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateUserInspect()

			m.MinimockDeleteUserInspect()

			m.MinimockGetUserInspect()

			m.MinimockUpdateUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockGetUserDone() &&
		m.MinimockUpdateUserDone()
}
